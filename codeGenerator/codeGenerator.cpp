#include "codeGenerator.h"

using namespace std;

int CodeGenerator::console_state_machine_code(){
    //Opens the file
    ofstream code_file;
    string code;
    code_file.open(code_file_name, ios_base::app);

    //Initializes a state machine var
    code = "//State Machine state\n";
    code += "int state = 0;\n\n";

    //Opens the state machine
    code += "switch(state){\n";

    //writes to the file
    code_file << code;

    //You need to close the file before call a function that opens it
    code_file.close();

    //For each state, calls the linear_function to write it's respective functions
    for(int i = 0; i < this->number_of_states; i++){

        code_file.open(code_file_name, ios_base::app);

        //Another state
        code = "\n	case '" + to_string(i) + "':\n";

        //writes to the file
        code_file << code;

        //You need to close the file before call a function that opens it
        code_file.close();

        //Write the linear code state
        this->console_linear_function(this->states_functions[i]);
    }

    //Opens the file
    code_file.open(code_file_name, ios_base::app);

    //Close the switch
    code = "\n    }\n";

    //writes to the file
    code_file << code;
    //You need to close the file before call a function that opens it
    code_file.close();

    return 0;
}

int CodeGenerator::console_start(){

    //Starts the generated code file
    ofstream code_file;
    string code;
    FILE * data_base;
    string s_modules;
    string input_modules = "";

    code_file.open(code_file_name);

    code = "//This code was generated by codeGenerator\n";
    //Fist, all the includes should be put here
    code = code + "#include<iostream>\n";

    //Writes to file
    code_file << code;
    code_file.close();

    //Writes the modules chosen by the user
    int i = 0;
    data_base = fopen(modules_data_base_path.c_str(), "rb");
    if(data_base != 0){
       while(this->modules_ids[i] != -1){
            fseek(data_base, (this->modules_ids[i]-1)*sizeof(code_generator_struct), SEEK_SET);
            fread(&data_for_modules, sizeof(code_generator_struct), 1, data_base);
            s_modules = data_for_modules.name;
            input_modules = input_modules + "\n";
            input_modules = input_modules + "#include<" +s_modules + ".h>";
            s_modules = "";
                    i++;
            }
        fclose(data_base);
        cout << input_modules << endl;
        code_file.open(code_file_name, ios_base::app);
        code_file << input_modules + "\n\n";
        code_file.close();
    }
    else{
        cout << "Error - Modules data base cannot be opened." << endl;
            return -1;
    }

    code_file.open(code_file_name, ios_base::app);

    //Namespace std, default in c++ applications
    code = "using namespace std;\n\n";
    //Starts the main function
    code = code + "int main(){\n";
    //Code....

    //Writes to file
    code_file << code;
    code_file.close();
}

void CodeGenerator::finish(){

    //Starts the generated code file
    ofstream code_file;
    string code;

    //Open the file to append
    code_file.open(code_file_name, ios_base::app);

    //Writes the main return and closes the code
    code = "\n";
    code = code + "	return 0;\n";
    code = code + "}";

    //Writes to file
    code_file << code;
    code_file.close();
}

void CodeGenerator::console_create_functions_database(){

    CodeGenerator code_gen;
    code_generator_struct new_m; //Struct that receives new function data
    FILE *data_base; //Pointer to data_base file
    cout << "    Put function ID: ";
    cin >> new_m.id;
    cin.ignore();//Ignores upper cin \n
    cout << endl << "    Put function name: ";
    cin.getline(new_m.name, 100);

    //Verify the input name
    while(check_function_name(new_m.name) != 0){
        cout << endl << "    Put function name: ";
        cin.getline(new_m.name, 100);
    }


    cout << "    	Put the name of the module that this function belongs to: ";
    cin.getline(new_m.module_of_function, 100);

    cout << endl << "    Put function return type: ";
    cin.getline(new_m.return_type, 100);

    cout << endl << "	Put the number of parameters: ";
    cin >> new_m.number_of_parameters;
    cin.ignore();

    //Insert all the parameters
    for(int i = 0; i < new_m.number_of_parameters; i++){
        cout <<  endl << "	  Put type of the parameter: ";
        cin.getline(new_m.param_types[i], 100);

        cout << endl << "	Put the name of the parameter: ";
        cin.getline(new_m.param_names[i], 100);
    }

    data_base = fopen(functions_data_base_path.c_str(), "r+b");
    fseek(data_base, (new_m.id-1)*sizeof(code_generator_struct), SEEK_SET);
    fwrite(&new_m, sizeof(code_generator_struct), 1, data_base);
    fclose(data_base);
}

int CodeGenerator::check_function_name(char* name){

    for(int i = 0; i < sizeof(name); i++){
        if(name[i] == '(' || name[i] == ')'){
            cout << "\nInvalid characters: ( or )" << endl;
            return 1;
        }
        if(name[i] == ';'){
            cout << "\nInvalid character: ;" << endl;
            return 1;
        }
        if(name[i] == ' ' && i < sizeof(name)-1){
            cout << "\nInvalid character: space in the name" << endl;
            return 1;
        }
    }

    return 0;

}


void CodeGenerator::console_create_modules_database(){

    code_generator_struct new_f; //Struct that receives new function data
    FILE *data_base; //Pointer to data_base file

    cout << "    Put module ID: ";
    cin >> new_f.id;
    cin.ignore();//Ignores upper cin \n
    cout << endl << "    Put module name: ";
    cin.getline(new_f.name, 100);

    //Verify the input name
    while(check_module_name(new_f.name) != 0){
        cout << endl << "    Put module name: ";
        cin >> new_f.name;
    }

    cout << endl << "    Put module classifier: ";
    cin.getline(new_f.module_classifier, 100);

    data_base = fopen(modules_data_base_path.c_str(), "r+b");
    fseek(data_base, (new_f.id-1)*sizeof(code_generator_struct), SEEK_SET);
    fwrite(&new_f, sizeof(code_generator_struct), 1, data_base);
    fclose(data_base);
}

int CodeGenerator::check_module_name(char* name){

    for(int i = 0; i < sizeof(name); i++){
        if(name[i] == '<' || name[i] == '>'){
            cout << "\nInvalid characters: < or >." << endl;
            return 1;
        }
        if(i < sizeof(name)-1 && name[i] == '.' && name[i+1] == 'h'){
            cout << "\nInvalid characters: .h" << endl;
            return 1;
        }
        if(name[i] == ' ' && i < sizeof(name)-1){
            cout << "\nInvalid characters: space in the name" << endl;
            return 1;
        }
    }

    return 0;

}

int CodeGenerator::console_linear_function(int id_functions[]){

    FILE * data_base;
    ofstream code_file;
    string s_functions;
    string linear_functions = "";
    int i = 0;

    data_base = fopen(functions_data_base_path.c_str(), "rb");
    if(data_base != 0){
       while(id_functions[i] != -1){
            fseek(data_base, (id_functions[i]-1)*sizeof(code_generator_struct), SEEK_SET);
            fread(&data_for_functions, sizeof(code_generator_struct), 1, data_base);
            s_functions = data_for_functions.name;
            linear_functions = linear_functions + "\n    ";

            //Write the variables according to the parameters names and types
            //Write parameters
            for(int j = 0; j < data_for_functions.number_of_parameters; j++){
                //Type
                linear_functions =  linear_functions + data_for_functions.param_types[j] + " ";
                //Name
                linear_functions = linear_functions + data_for_functions.param_names[j] + ";\n    ";
            }

            //Write the return variable
            linear_functions = linear_functions + data_for_functions.return_type + " " + data_for_functions.name + "_"
                + "return = ";

            linear_functions = linear_functions + s_functions + "(";

            //Write parameters
            for(int j = 0; j < data_for_functions.number_of_parameters; j++){
                //Name
                linear_functions = linear_functions + data_for_functions.param_names[j];

                if(j < data_for_functions.number_of_parameters - 1){
                    linear_functions = linear_functions + ", ";
                }
            }
            linear_functions = linear_functions + ");\n";

            s_functions = "";
                    i++;
            }
        fclose(data_base);
        cout << linear_functions << endl;
        code_file.open(code_file_name, ios_base::app);
        code_file << linear_functions;
        code_file.close();
    }
    else{
        cout << "Error - Functions data base cannot be opened." << endl;
            return -1;
    }
    return 0;
}

void CodeGenerator::initial_setup(){

    //Starts the generated code file
    ofstream code_file;
    string code;

    //Open the file to append
    code_file.open(code_file_name, ios_base::app);

    code = "\n";
    code = code + "	//Code for the initial setup\n";
    code = code + "	system_init();\n";
    code = code + "	system_config();\n";
    code = code + "\n";

    //Writes to file
    code_file << code;
    code_file.close();
}

//Inteface functions

int CodeGenerator::console_initial_menu(){

    int user_choice;

    //Prints the menu
    system("clear");
    cout << "=================================================" << endl;
    cout << "=              Aker - Code Generator            =" << endl;
    cout << "=================================================" << endl;
    cout << "  Choose an option:                             " << endl;
    cout << "    1. Register a function;                    " << endl;
    cout << "    2. Register a module;                      " << endl;
    cout << "    3. Generate code;                            " << endl;
    cout << "    4. Exit;                                     " << endl;
    cout << "  Your choice: ";

    //Reads the user choice
    cin  >>  user_choice;

    //Updates the class attribute with the user choice
    this->user_choice = user_choice;
}

void CodeGenerator::console_new_function(){

    //Prints the header
    system("clear");
    cout << "=================================================" << endl;
    cout << "=              Aker - Code Generator            =" << endl;
    cout << "=================================================" << endl;

    //Calls the function that creates the functions database
    this->console_create_functions_database();

}

void CodeGenerator::console_new_module(){

    //Prints the interface
    system("clear");
    cout << "=================================================" << endl;
    cout << "=              Aker - Code Generator            =" << endl;
    cout << "=================================================" << endl;

    //Calls the functions that creates the modules database
    this->console_create_modules_database();

}

void CodeGenerator::console_insert_modules(){

    int number_of_modules;
    int *modules_ids;

    //Prints the interface
    system("clear");
    cout << "=================================================" << endl;
    cout << "=              Aker - Code Generator            =" << endl;
    cout << "=================================================" << endl;
    cout << "  How many modules do you want?                  " << endl;

    //Handles the reading of the modules IDs
    cin  >> number_of_modules;
    modules_ids = (int*)malloc((number_of_modules+1)*sizeof(int));
    *(modules_ids + number_of_modules) = -1;
    cout << "  Entry modules IDs:                           " << endl;
    for(int i = 0; i<number_of_modules ; i++){
        cin  >> *(modules_ids + i);
    }

    this->modules_ids = modules_ids;
}

void CodeGenerator::console_insert_functions(){

    int number_of_states;
    int **states_functions;
    int number_of_functions;

    //Prints the interface for the state machine
    system("clear");
    cout << "=================================================" << endl;
    cout << "=              Aker - Code Generator            =" << endl;
    cout << "=================================================" << endl;
    cout << "  How many states do you want?                  " << endl;

    //Reads the number of states that the program will have
    cin  >> number_of_states;
    this->number_of_states = number_of_states;
    //allocates memory for the states_function** rows
    states_functions = (int**)malloc(number_of_states*sizeof(int*));

    //For each state, read its functions
    for(int i = 0; i<number_of_states ; i++){

        //Prints the interface for adding functions to the states
        system("clear");
        cout << "=================================================" << endl;
        cout << "=              Aker - Code Generator            =" << endl;
        cout << "=================================================" << endl;
        cout << "  How many functions do you want in state " << i << "?" << endl;
        cin  >> number_of_functions;
        //allocates memory for the states_functions** cols
        states_functions[i] = (int*)
                            malloc((number_of_functions+1)*sizeof(int));
        *(states_functions[i] + number_of_functions) = -1;
        cout << "  Entry functions IDs:                           " << endl;
        for(int j = 0; j<number_of_functions ; j++){
                cin  >> states_functions[i][j];
        }
    }

    this->states_functions = states_functions;
}

void CodeGenerator::ui_initial_menu(int user_choice){
    this->set_user_choice(user_choice);
}

void CodeGenerator::ui_new_function(int function_id, char* function_name, char* module_of_function, char* return_type,
                                                int number_of_parameters, char** param_types_list,
                                                char** param_names_list){

    this->set_function_id(function_id);
    this->set_function_name(function_name);
    this->set_module_of_function(module_of_function);
    this->set_return_type(return_type);
    this->set_number_of_parameters(number_of_parameters);
    this->set_param_types_list(param_types_list);
    this->set_param_names_list(param_names_list);
    this->ui_create_functions_database();

}

void CodeGenerator::ui_new_module(int module_id, char* module_name, char* module_classifier){

    this->set_module_id(module_id);
    this->set_module_name(module_name);
    this->set_module_classifier(module_classifier);

    this->ui_create_modules_database();
}

void CodeGenerator::ui_insert_modules(int number_of_modules, int* modules_ids){
    this->number_of_modules = number_of_modules;
    this->modules_ids = modules_ids;
}

void CodeGenerator::ui_insert_functions(int number_of_states, int* functions_per_state, int **states_functions){
    this->number_of_states = number_of_states;

    this->states_functions = (int **)malloc(this->number_of_states * sizeof(int*));

    for(int i = 0; i < this->number_of_states; i++){
        this->states_functions[i] = (int *)malloc(functions_per_state[i] * sizeof(int));
        for(int j = 0; j < functions_per_state[i] + 1; j++){
            if(j < functions_per_state[i]){
                this->states_functions[i][j] = states_functions[i][j];
            }
            else{
                this->states_functions[i][j] = -1;
            }
        }
    }
}

void CodeGenerator::ui_create_functions_database(){
    code_generator_struct new_m; //Struct that receives new function data
    FILE *data_base; //Pointer to data_base file

    new_m.id = this->function_id;
    strcpy(new_m.name, this->function_name);
    strcpy(new_m.module_of_function, this->module_of_function);
    strcpy(new_m.return_type, this->return_type);
    new_m.number_of_parameters = this->number_of_parameters;

    for(int i = 0; i < new_m.number_of_parameters; i++){
        strcpy(new_m.param_types[i], this->param_types_list[i]);
        strcpy(new_m.param_names[i], this->param_names_list[i]);
    }

    data_base = fopen(functions_data_base_path.c_str(), "r+b");
    if(data_base == NULL){
        data_base = fopen(functions_data_base_path.c_str(), "w+b");
    }
    fseek(data_base, (new_m.id-1)*sizeof(code_generator_struct), SEEK_SET);
    fwrite(&new_m, sizeof(code_generator_struct), 1, data_base);
    fclose(data_base);
}

void CodeGenerator::ui_create_modules_database(){
    code_generator_struct new_f; //Struct that receives new module data
    FILE *data_base; //Pointer to data_base file
    new_f.id = this->module_id;
    strcpy(new_f.name, this->module_name);
    strcpy(new_f.module_classifier, this->module_classifier);

    data_base = fopen(modules_data_base_path.c_str(), "r+b");
    if(data_base == NULL){
        data_base = fopen(modules_data_base_path.c_str(), "w+b");
    }
    fseek(data_base, (new_f.id-1)*sizeof(code_generator_struct), SEEK_SET);
    fwrite(&new_f, sizeof(code_generator_struct), 1, data_base);
    fclose(data_base);
}

void CodeGenerator::console_generate(){

    //Insert modules
    this->console_insert_modules();

    //Insert functions
    this->console_insert_functions();

    //Starts the code
    this->console_start();

    //Write the  code
    this->console_state_machine_code();

    //Finishes the code
    this->finish();
}

void CodeGenerator::ui_generate(int number_of_modules, int* modules_ids,
     int* functions_per_state, int number_of_states, int **states_functions){

    //Insert modules
    this->ui_insert_modules(number_of_modules, modules_ids);

    //Insert functions
    this->ui_insert_functions(number_of_states, functions_per_state, states_functions);

    //Starts the code
    this->ui_start();

    //Write the  code
    this->ui_state_machine_code();

    //Finishes the code
    this->finish();
}

int CodeGenerator::ui_start(){

    //Starts the generated code file
    ofstream code_file;
    string code;
    FILE * data_base;
    string s_modules;
    string input_modules = "";

    code_file.open(code_file_name);

    code = "//This code was generated by codeGenerator\n";
    //Fist, all the includes should be put here
    code = code + "#include<iostream>\n";

    //Writes to file
    code_file << code;
    code_file.close();

    //Writes the modules chosen by the user
    data_base = fopen(modules_data_base_path.c_str(), "rb");
    if(data_base != 0){
       for(int i = 0; i < this->number_of_modules; i++){
            fseek(data_base, (this->modules_ids[i]-1)*sizeof(code_generator_struct), SEEK_SET);
            fread(&data_for_modules, sizeof(code_generator_struct), 1, data_base);
            s_modules = data_for_modules.name;
            input_modules = input_modules + "\n";
            input_modules = input_modules + "#include<" +s_modules + ".h>";
            s_modules = "";            }
        fclose(data_base);
        cout << input_modules << endl;
        code_file.open(code_file_name, ios_base::app);
        code_file << input_modules + "\n\n";
        code_file.close();
    }
    else{
        cout << "Error - Modules data base cannot be opened." << endl;
            return -1;
    }

    code_file.open(code_file_name, ios_base::app);

    //Namespace std, default in c++ applications
    code = "using namespace std;\n\n";
    //Starts the main function
    code = code + "int main(){\n";
    //Code....

    //Writes to file
    code_file << code;
    code_file.close();
}

int CodeGenerator::ui_state_machine_code(){
    //Opens the file
    ofstream code_file;
    string code;
    code_file.open(code_file_name, ios_base::app);

    //Initializes a state machine var
    code = "//State Machine state\n";
    code += "int state = 0;\n\n";

    //Opens the state machine
    code += "switch(state){\n";

    //writes to the file
    code_file << code;

    //You need to close the file before call a function that opens it
    code_file.close();

    //For each state, calls the linear_function to write it's respective functions
    for(int i = 0; i < this->number_of_states; i++){

        code_file.open(code_file_name, ios_base::app);

        //Another state
        code = "\n	case '" + to_string(i) + "':\n";

        //writes to the file
        code_file << code;

        //You need to close the file before call a function that opens it
        code_file.close();

        //Write the linear code state
        this->ui_linear_function(this->states_functions[i]);
    }

    //Opens the file
    code_file.open(code_file_name, ios_base::app);

    //Close the switch
    code = "\n    }\n";

    //writes to the file
    code_file << code;
    //You need to close the file before call a function that opens it
    code_file.close();

    return 0;
}

int CodeGenerator::ui_linear_function(int id_functions[]){

    FILE * data_base;
    ofstream code_file;
    string s_functions;
    string linear_functions = "";
    int i = 0;

    data_base = fopen(functions_data_base_path.c_str(), "rb");
    if(data_base != 0){
       while(id_functions[i] != -1){
            fseek(data_base, (id_functions[i]-1)*sizeof(code_generator_struct), SEEK_SET);
            fread(&data_for_functions, sizeof(code_generator_struct), 1, data_base);
            s_functions = data_for_functions.name;
            linear_functions = linear_functions + "\n    ";

            //Write the variables according to the parameters names and types
            //Write parameters
            for(int j = 0; j < data_for_functions.number_of_parameters; j++){
                //Type
                linear_functions =  linear_functions + data_for_functions.param_types[j] + " ";
                //Name
                linear_functions = linear_functions + data_for_functions.param_names[j] + ";\n    ";
            }

            //Write the return variable
            linear_functions = linear_functions + data_for_functions.return_type + " " + data_for_functions.name + "_"
                + "return = ";

            linear_functions = linear_functions + s_functions + "(";

            //Write parameters
            for(int j = 0; j < data_for_functions.number_of_parameters; j++){
                //Name
                linear_functions = linear_functions + data_for_functions.param_names[j];

                if(j < data_for_functions.number_of_parameters - 1){
                    linear_functions = linear_functions + ", ";
                }
            }
            linear_functions = linear_functions + ");\n";

            s_functions = "";
                    i++;
            }
        fclose(data_base);
        cout << linear_functions << endl;
        code_file.open(code_file_name, ios_base::app);
        code_file << linear_functions;
        code_file.close();
    }
    else{
        cout << "Error - Functions data base cannot be opened." << endl;
            return -1;
    }
    return 0;
}

    //Setters
void CodeGenerator::set_user_choice(int user_choice){
    this->user_choice = user_choice;
}

void CodeGenerator::set_modules_ids(int* modules_ids){
    this->modules_ids = modules_ids;
}

void CodeGenerator::set_number_of_states(int number_of_states){
    this->number_of_states = number_of_states;
}

void CodeGenerator::set_states_functions(int** states_functions){
    this->states_functions = states_functions;
}

void CodeGenerator::set_function_id(int function_id){
    this->function_id = function_id;
}

void CodeGenerator::set_function_name(char* function_name){
    strcpy(this->function_name, function_name);
}

void CodeGenerator::set_return_type(char* return_type){
    strcpy(this->return_type, return_type);
}

void CodeGenerator::set_number_of_parameters(int number_of_parameters){
    this->number_of_parameters = number_of_parameters;
}

void CodeGenerator::set_param_types_list(char** param_types_list){
    for(int i = 0; i < this->number_of_parameters; i++){
        strcpy(this->param_types_list[i], param_types_list[i]);
    }
}

void CodeGenerator::set_param_names_list(char** param_names_list){
    for(int i = 0; i < this->number_of_parameters; i++){
        strcpy(this->param_names_list[i], param_names_list[i]);
    }
}

void CodeGenerator::set_module_id(int module_id){
    this->module_id = module_id;
}

void CodeGenerator::set_module_name(char* module_name){
    strcpy(this->module_name, module_name);
}

void CodeGenerator::set_number_of_modules(int number_of_modules){
    this->number_of_modules = number_of_modules;
}

void CodeGenerator::set_module_classifier(char* classifier){
    strcpy(this->module_classifier, classifier);
}

void CodeGenerator::set_module_of_function(char* module_of_function){
    strcpy(this->module_of_function, module_of_function);
}

//Gettes
int CodeGenerator::get_user_choice(){
    return this->user_choice;
}

int* CodeGenerator::get_modules_ids(){
    return this->modules_ids;
}

int CodeGenerator::get_number_of_states(){
    return this->number_of_states;
}

int** CodeGenerator::get_states_functions(){
    return this->states_functions;
}

int CodeGenerator::get_function_id(){
    return this->function_id;
}

char* CodeGenerator::get_function_name(){
    return this->function_name;
}

char* CodeGenerator::get_return_type(){
    return this->return_type;
}

int CodeGenerator::get_number_of_parameters(){
    return this->number_of_parameters;
}

char** CodeGenerator::get_param_types_list(){
    char** param_types_list = (char **) malloc(this->number_of_parameters *
                                                sizeof(char *));
    for(int i = 0; i < this->number_of_parameters; i++){
        param_types_list[i] = (char *)malloc(100 * sizeof(char));
        param_types_list[i] = this->param_types_list[i];
    }
    return param_types_list;
}

char** CodeGenerator::get_param_names_list(){
    char** param_names_list = (char **) malloc(this->number_of_parameters *
                                                sizeof(char *));
    for(int i = 0; i < this->number_of_parameters; i++){
        param_names_list[i] = (char *)malloc(100 * sizeof(char));
        param_names_list[i] = this->param_names_list[i];
    }
    return param_names_list;
}

int CodeGenerator::get_module_id(){
    return this->module_id;
}

char* CodeGenerator::get_module_name(){
    return this->module_name;
}

int CodeGenerator::get_number_of_modules(){
    return this->number_of_modules;
}

char* CodeGenerator::get_module_classifier(){
    return this->module_classifier;
}

char* CodeGenerator::get_module_of_function(){
    return this->module_of_function;
}


char** CodeGenerator::get_all_modules_names_by_classifier(char* classifier){

    FILE * data_base;
    char** modules_names;

    modules_names = (char **)malloc(100 * sizeof(char*));
    for(int i = 0; i < 100; i++){
        modules_names[i] = (char *)malloc(100 * sizeof(char));
    }

    data_base = fopen(modules_data_base_path.c_str(), "rb");
    if(data_base != NULL){

        fseek(data_base, 0L, SEEK_END);
        int sz = ftell(data_base);
        fseek(data_base, 0L, SEEK_SET);

        int modules_names_index = 0;
        for(int i = 0; i < sz/sizeof(code_generator_struct); i++){
            fseek(data_base, i*sizeof(code_generator_struct), SEEK_SET);
            fread(&data_for_modules, sizeof(code_generator_struct), 1, data_base);
            if(strcmp(data_for_modules.module_classifier, classifier)==0 && data_for_modules.id != 0){
                strcpy(modules_names[modules_names_index], data_for_modules.name);
                modules_names_index++;
            }
        }

        fclose(data_base);
    }

    return modules_names;
}

char** CodeGenerator::get_all_functions_of_a_module(char* module_name){

    FILE * data_base;
    char** function_names;

    function_names = (char **)malloc(100 * sizeof(char*));
    for(int i = 0; i < 100; i++){
        function_names[i] = (char *)malloc(100 * sizeof(char));
    }

    data_base = fopen(functions_data_base_path.c_str(), "rb");
    if(data_base != NULL){

        fseek(data_base, 0L, SEEK_END);
        int sz = ftell(data_base);
        fseek(data_base, 0L, SEEK_SET);

        int functions_names_index = 0;
        for(int i = 0; i < sz/sizeof(code_generator_struct); i++){
            fseek(data_base, i*sizeof(code_generator_struct), SEEK_SET);
            fread(&data_for_functions, sizeof(code_generator_struct), 1, data_base);
            if(strcmp(data_for_functions.module_of_function, module_name)==0 && data_for_functions.id != 0){
                strcpy(function_names[functions_names_index], data_for_functions.name);
                functions_names_index++;
            }
        }

        fclose(data_base);
    }

    return function_names;
}

int CodeGenerator::get_function_id_by_name(char* function_name){
    FILE * data_base;
    int id = -1;

    data_base = fopen(functions_data_base_path.c_str(), "rb");
    if(data_base != NULL){

        fseek(data_base, 0L, SEEK_END);
        int sz = ftell(data_base);
        fseek(data_base, 0L, SEEK_SET);

        for(int i = 0; i < sz/sizeof(code_generator_struct); i++){
            fseek(data_base, i*sizeof(code_generator_struct), SEEK_SET);
            fread(&data_for_functions, sizeof(code_generator_struct), 1, data_base);
            if(strcmp(data_for_functions.name, function_name)==0){
                return data_for_functions.id;
            }
        }

        fclose(data_base);
    }

    return id;
}

int CodeGenerator::get_module_id_by_name(char* module_name){
    FILE * data_base;
    int id = -1;

    data_base = fopen(modules_data_base_path.c_str(), "rb");
    if(data_base != NULL){

        fseek(data_base, 0L, SEEK_END);
        int sz = ftell(data_base);
        fseek(data_base, 0L, SEEK_SET);

        for(int i = 0; i < sz/sizeof(code_generator_struct); i++){
            fseek(data_base, i*sizeof(code_generator_struct), SEEK_SET);
            fread(&data_for_modules, sizeof(code_generator_struct), 1, data_base);
            if(strcmp(data_for_modules.name, module_name)==0){
                return data_for_modules.id;
            }
        }

        fclose(data_base);
    }

    return id;
}

//Initializes the state machine counter
int CodeGenerator::curr_state_number = 0;
